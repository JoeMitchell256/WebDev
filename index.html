<!DOCTYPE html>
<html>
  <head>
    <title>Visualizing Fourier Coefficients</title> <!-- Title of our website in browser -->
    <link rel="stylesheet" type="text/css" href="style.css">
    <canvas id="back" width="1420" height="550" style="border:1px solid #000000"></canvas>
    <canvas id="myCanvas" width="1420" height="550" style="border:1px solid #000000"></canvas>
    <script> 
      
      var c = document.getElementById("myCanvas");
      var ctx = c.getContext("2d");
      var n, pulsefunction, xMin, xMax, FourierWidth, FourierColor, SquareWidth, SquareColor;
      
      //All four of the below functions are helper functions to make the x limits fully modular!
      function drawXaxis(ctx,xstart,yend,xend,twopi,ycenter,i){ <!-- This function holds all related x axis code -->
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        
        // X-axis Line
        ctx.moveTo(xstart-50,ycenter);
        ctx.lineTo(xend,ycenter); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        
        // X-axis title
        ctx.fillText("t/T",(xstart + xend)/2,yend + 100);
        
        // X-axis scale
        /*
        var counter = 1;//The mathematical escape character for pi should be : \u03C0
        var p = 0;
        for(p=0; p < 3; p++){//Loop for each period
          for(i=0; i < 2; i++){//Loop for each pulse value (i < pulsearray.length)
            if(counter == 1){
              ctx.fillText( "\u03C0",xstart+(twopi/2)*(counter),yend + 60); //Should label every pi only
            }else{
              ctx.fillText( counter+"\u03C0",xstart+(twopi/2)*(counter),yend + 60); //Should label every pi only
            }
            counter++;//Increment 2pi for x-axis
          }
        }
        */
        ctx.stroke();
      }
      
      function drawYaxis(ctx,xstart,ytop,yend,ycenter,max,i,xend){ <!-- This function holds all related y axis code -->
        
        // Y-axis line
        //ctx.lineWidth = 15;
        //ctx.strokeStyle = '#00FF00';
        
        var xpos = 0;
        
        if(xMin >= 1 && xMax >= 1){
          xpos = xstart;
        }
        if(xMin <= -1 && xMax <= -1){
          xpos = xend;
        }
        
        ctx.moveTo(xpos,ytop);
        ctx.lineTo(xpos,yend); <!-- This needs to be placed based on the x limits provided by the user... -->
        
        ctx.stroke();//I just want to color the line that is the y axis...
        
        //ctx.beginPath();
        //ctx.lineWidth = 1;
        //ctx.strokeStyle = '#000000';
        
        // Y-axis scale and y-axis gridlines...
        var yScalePos = 0;
        for(i = -max; i < max+1; i++){ //Can I draw the x-scale here as well?
          yScalePos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * i ) + ycenter;
          if(xMin >= 1 && xMax >= 1){
            if(i >= 0){//This shift should be modulated based on the x limits
              ctx.fillText(i, xpos - 30, yScalePos);//Further shift the y scale off of the y axis for visibility
            }else{
              ctx.fillText(i, xpos - 50, yScalePos);//Further shift the y scale off of the y axis for visibility
            }
          }
          if(xMin <= -1 && xMax <= -1){//Shift y scale to the right
            if(i >= 0){//This shift should be modulated based on the x limits
              ctx.fillText(i, xpos + 15, yScalePos);//Further shift the y scale off of the y axis for visibility
            }else{
              ctx.fillText(i, xpos + 25, yScalePos);//Further shift the y scale off of the y axis for visibility
            }
          }
          ctx.moveTo(xstart,yScalePos);
          ctx.lineTo(xend,yScalePos);
          ctx.stroke();
        }
        // Y-axis title
        if(xMin >= 1 && xMax >= 1){
          ctx.fillText("f(t)",xpos - 75,ycenter - 20);
        }
        if(xMin <= -1 && xMax <= -1){//Shift y scale to the right
          ctx.fillText("f(t)",xpos + 35,ycenter - 20);
        }
        ctx.stroke();
        
        ctx.beginPath();
        //ctx.stroke();
      }
      
      function drawGridlines(ctx,xstart,xend,ytop,yend,i){ <!-- This function holds all related gridlines creation -->
        <!-- Add the y-axis gridlines here -->
        //This should be modular based on the limits provided by the user. So, whatever our x axis range is, should determine the placement of the axis
        
        var numVertical = Math.abs(Math.ceil(xMax) - Math.floor(xMin)); //This should be the total number of lines that are required for the modular graph creation.
        
        var min = Math.floor(xMin);
        var max = Math.ceil(xMax);
        //Now that we have the total number of vertical gridlines, we need to determine how to place the lines on the x axis
        
        var xSize = xend - xstart;
        var interval = 0;
        var counter = 0;
        var count = min;
        
        interval = xSize / numVertical;
        
        if(min <= -1 && max <= -1){//Y-axis right justified   Case #1
          interval = xSize / (numVertical + 1); //Interval between each of the vertical axis
        }
        if(min >= 1 && max >= 1){//Y-axis left justified    Case #2
          interval = xSize / (numVertical + 1); //Interval between each of the vertical axis
        }
        
        //The ultimate goal of this is to make sure that all of the vertical axis can be fit in a way that the user can see the entire graph without the need for
        //a scroll bar
        
        if (min < 0 && max < 0){//When min is -3 and max is -1, I expect that there will be vertical gridlines drawn from current y-axis position to the 
          for(i=Math.abs(min); i>=(Math.abs(max)); i--){//second to last position.
            if( (i % 2) == 0){
              ctx.beginPath();
              ctx.lineWidth = 8; //For 2 pi make the gridline thickness larger
            }
            if( (i % 2) != 0){//This modification should place the proper 2pi vertical gridlines!
              ctx.beginPath();
              ctx.lineWidth = 1; //Make pi line width equal to 1.
            }
            ctx.moveTo(xstart+interval*(counter) , ytop);
            ctx.lineTo(xstart+interval*(counter) , yend);
            
            if(count == 1 || count = -1){
              ctx.fillText( "\u03C0",xstart+interval*(counter),yend + 20); //Should label every pi only
            }else{
              ctx.fillText( count+"\u03C0",xstart+interval*(counter),yend + 20); //Should label every pi only
            }
            
            
            counter++;
            count++;
            ctx.stroke();
          }
        }
        if (min > 0 && max > 0){
          for(i=Math.abs(min); i<(Math.abs(max)+1); i++){
            if( (i % 2) == 0){//Why is this never executing?
              ctx.beginPath();
              ctx.lineWidth = 8; //For 2 pi make the gridline thickness larger
            }
            if( (i % 2) != 0){//This modification should place the proper 2pi vertical gridlines!
              ctx.beginPath();
              ctx.lineWidth = 1; //Make pi line width equal to 1.
            }
            ctx.moveTo(xstart+interval*(counter + 1) , ytop);
            ctx.lineTo(xstart+interval*(counter + 1) , yend);
            
            if(count == 1 || count == -1){
              ctx.fillText( "\u03C0",xstart+interval*(counter),yend + 20); //Should label every pi only
            }else{
              ctx.fillText( count+"\u03C0",xstart+interval*(counter),yend + 20); //Should label every pi only
            }
            
            counter++;
            count++;
            ctx.stroke();
          }
        }
        ctx.lineWidth = 1;
        // x-axis gridlines
      }
      
      function drawFunctions(){ <!-- This function will graph the square wave and fourier series equations -->
        
      }
      
      function drawGraph(pulsefunction,c,ctx,n,xmin,xmax,fw,fc,sw,sc){//We need to know what attributes need to be passed to this function
        //Calculate the point value for the xmin and xmax inputs
        var twopi = 450;
        xmin = parseFloat(xmin);
        xmax = parseFloat(xmax);
        var xMinPval = Math.ceil(twopi/2 * parseFloat(xmin));
        var xMaxPval = Math.ceil(twopi/2 * parseFloat(xmax));
        var i = 0;
        var pulsearray = pulsefunction.split(" ");//Take input as an array of values split on single space
      
        //In a for loop find the maximum/minimum value, use the absolute value so you'll only be using positive numbers as reference
        
        var max = -Infinity;
        
        for(i = 0; i < pulsearray.length; i++){
          if(Math.abs(parseInt(pulsearray[i])) > max){
            max = Math.abs(parseInt(pulsearray[i]));
          }
        }
        
        //By this point we should know our y scale. Whatever our max value is we should have that be our max positive/negative range. 
        //This might not work as I am expecting it to work, however thats alright we'll do it now, then change it later if so.
        
      
        <!-- End of input reading -->
        
        c = document.getElementById("myCanvas");
        ctx = c.getContext("2d");
        
        ctx.clearRect(0,0,1420,500);
        ctx.beginPath(); //Apparently we need this line???
        
        //We should probably draw the y and x axis here, so that we can properly scale the graph first...
        // I'd love to do this, but javascript wont let me...
        
        <!-- This is the start of the square wave -->
        <!-- Any state transitions will require 3 lines, not 2. -->
        <!-- pi/2 and 2pi/2 are tied to 5pi/2 and 6pi/2, and 9pi/2 and 10pi/2 -->
        
        <!-- Y-axis modular variables -->
        
        var ycenter = 250;
        var ytop = 50;
        var yend = 450;
        
        <!-- Y-axis modular variables end -->
        
        <!-- X-axis modular variables -->
        
        var xstart = 100;
        var xend = 1300;
        
        <!-- X-axis modular variables end -->
        
        
        //Style
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        
        <!-- So this means that each interval is in 450 pixels, so the text will look like pi/2 , 2pi/2, 3pi/2, ... until 12pi/2 -->

        ctx.font = "30px Courier New";

        //ctx.font = "30px Courier New";
        
        var xpos = 0;
        
        if(xMin >= 1 && xMax >= 1){
          xpos = xstart;
        }
        if(xMin <= -1 && xMax <= -1){
          xpos = xend;
        }
        
        this.drawGridlines(ctx,xstart,xend,ytop,yend,i);
        
        ctx.stroke();
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        
        <!-- End of Y-axis creation -->
        
        <!-- Draw new axis for both graphs -->
        
        <!-- New x-axis -->
        
        ctx.moveTo(xstart-50,ycenter);
        ctx.lineTo(xend,ycenter); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        ctx.stroke();
        
        <!-- End new x-axis -->
      
        this.drawXaxis(ctx,xstart,yend,xend,twopi,ycenter,i);
        
        
        this.drawYaxis(ctx,xstart,ytop,yend,ycenter,max,i,xend);
        
        
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        ctx.globalAlpha = 1.0;
        <!-- This is where the points must be drawn!!!  -->
        <!-- This section of the program will plot the points for the Fourier Series! -->
        <!-- For sake of simplicity I'm going to hold off on the "0000" and "1111" waves -->

        
        //We need a robust way to calculate the integrals for the fourier coefficients
        
        //General Form for a_0 START ************************************
        //Average of the pulses
        
        var a0 = 0;
        var m = 0;
        for(m=0; m<pulsearray.length; m++){
           a0 += parseInt(pulsearray[m]); //a_0 portion
        }
        
        a0 = a0/(pulsearray.length); //division by 4 was not modular
        
        //General Form for a_0  END ************************************
        
        //General Form for a_n  START ************************************
        
        //No matter what the scenario, the integral always comes out the same. I will provide my handcalculations if necessary.
        function a_n(upper,lower,s,n){
          return ( ( Math.sin(upper*n) - Math.sin(lower*n) ) * parseInt(s) )/(Math.PI*n);
        }
        
        var aN = 0;
        
        //General Form for a_n  END ************************************
        
        //General Form for b_n  START ************************************
        
        function b_n(upper,lower,s,n){//Same as a_n but now its cos instead of sin from handcalculations
          return ( ( Math.cos(upper*n) - Math.cos(lower*n) ) * parseInt(s) )/(-1*Math.PI*n);
        }
        
        var bN = 0;
        
        //General Form for b_n END **************************************
        
        //Overall f(t) = a_0 + a_n*cos(n*t) + b_n*sin(n*t)
        //Now we can combine all three for loops into one just below this line for simplicity:
        
        var z = 0;
        var m = 0;
        n = parseInt(n);
        var p = 0;
        var y = a0;
        var aN = 0;
        var bN = 0;
        
        var coordinates = [];
        var points = [];
        var square = [];
        
        function storePointValues(xVal,yVal,array){
          array.push({x: xVal, y: yVal});
        }
        
        function squareYpos(p,twopi){//Based on the point value this function will return the y pulse value
          //Take the point value and place the value in the range from 0 to twopi (450)
          //Then determine if the point belongs to the particular pulsevalue
          var pulse = p;
          while(pulse > twopi){
            pulse = pulse - twopi;
          }
          var squareY = 0;
          for(i = 0; i < pulsearray.length; i++){
            if(pulse < (i + 1) * twopi/pulsearray.length && pulse >= i * twopi/pulsearray.length){
              squareY = pulsearray[i]; //Assign the proper pulse value based on the point index
            }
          }
          return squareY; //Return the proper pulse value based on the point index
        }
        
        //We need to make this modular. If we have 3 pulses, then we need to divide 2pi by 3, so instead of pi/2 we'll have pi/3's
        //We also do not know how many divisions we'll have, so we need to modulate it.
        //We should make the below into a function, that way it wont take so long for us to display 
        function drawFourierSeries(n){
            for(p = 0; p<1350; p++){//1350
              for(z = 0; z<n; z++){ //Include n number of terms in the fourier series expansion
                for(i = 0; i < pulsearray.length; i++){
                  aN += parseInt(pulsearray[i]) *  ( Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( (z+1) * Math.PI );
                  bN += parseInt(pulsearray[i]) *  ( Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( -1 * (z+1) * Math.PI );
                }
                y += aN*Math.cos((z+1)*(p+1)*(Math.PI/225)) + bN*Math.sin((z+1)*(p+1)*(Math.PI/225));//Increment by 1/100 th instead of 1?
                //Reset aN and bN in here?
                aN = 0;
                bN = 0;
              }
              if(p < twopi){
                storePointValues(p,y,points);//store 2pi worth of points
              }
              var y_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * y ) + ycenter;//This y scale converter should provide the proper canvas point y position for the point placement 
              storePointValues(xstart + 1*(p+1), y_pos, coordinates);
              //Determine the pulse value based on the point index using the squareYpos function defined above
              var square_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * squareYpos(p,twopi) ) + ycenter;
              storePointValues(xstart + 1*(p+1), square_pos, square);
              y = a0;
            }
            //Fourier Series smooth line
            ctx.beginPath();
            ctx.lineWidth = parseInt(fw);//Line thickness of the Fourier Series
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(coordinates[xMinPval].x, coordinates[xMinPval].y);//This moveTo is now robust
            for(i=1; i<coordinates.length-2; i++){
              if(i >= xMinPval && i < xMaxPval){
                var xc = (coordinates[i].x + coordinates[i + 1].x) / 2;
                var yc = (coordinates[i].y + coordinates[i + 1].y) / 2;
                ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,xc,yc);
              }
            }
            ctx.strokeStyle = fc;//Color of the Fourier Series line '#775500'
            if(i >= xMinPval && i < xMaxPval){
              ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,coordinates[i+1].x,coordinates[i+1].y);
            }
            ctx.stroke();
            //Square wave smooth line
            ctx.beginPath();
            ctx.lineWidth = parseInt(sw);//Line thickness of the square wave
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(square[xMinPval].x, square[xMinPval].y);
            for(i=1; i<square.length-2; i++){
              if(i >= xMinPval && i < xMaxPval){
                var xc = (square[i].x + square[i + 1].x) / 2;
                var yc = (square[i].y + square[i + 1].y) / 2;
                ctx.quadraticCurveTo(square[i].x,square[i].y,xc,yc);
              }
            }
            ctx.strokeStyle = sc;//Different color for square wave '#00FF00'
            if(i >= xMinPval && i < xMaxPval){
              ctx.quadraticCurveTo(square[i].x,square[i].y,square[i+1].x,square[i+1].y);
            }
            ctx.stroke();
        }
        //I need to save the image of the canvas before we draw the Fourier Series
        ctx.stroke();
        drawFourierSeries(n);
        //To develop the y scale converter we need to know the position of the Max/Min element (This should be at the very top and/or very bottom of the y axis)
        //Max y coordinate: 20  Min y coordinate: 480, so we should have 3 points really, Max, Min, center
        //Center y coordinate: 250
        
        // (max,480) , (0,250)
        //We can make a line like last time with 2 points the y intercept and the max for simplicity:
        //y = mx + b
        //b = 250
        //m = (max-0)/(480-250)
        //y = ( (250-20) )/(0-max)  * y_ + 250
        <!-- Calculate the average error per period -->
        var error = 0;
        for(p = 0; p < twopi; p++){//We need to figure out which points belong to which pulse value
          for(i = 0; i < pulsearray.length; i++){
            if(p < (twopi/pulsearray.length) * (i+1) && p > (twopi/pulsearray.length) * i){//If the point lies inside pulse value index i:
              error += Math.abs(points[p].y - pulsearray[i]); //Absolute value of the difference between the approximation and actual point value.
            }
          }
        }
        //Now to get the average we need to take the error and divide it by 450 because there are 450 points per period.
        error = error / 450;
        ctx.fillText("Average error: " + error,10,yend+30);//Place average error on the top left hand corner of canvas
        
      }
      
      function getInputValue(){
        
        pulsefunction = document.getElementById("pulse").value;
        n = document.getElementById("n").value;
        xMin = document.getElementById("xMin").value;
        xMax = document.getElementById("xMax").value;
        FourierWidth = document.getElementById("FourierWidth").value;
        FourierColor = document.getElementById("FourierColor").value;
        SquareWidth = document.getElementById("SquareWidth").value;
        SquareColor = document.getElementById("SquareColor").value;
        
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
        
      }
      
      function addOneTerms(){
        n = n+1;
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
      }
      function subOneTerms(){
        n = n-1;
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
      }
      
    </script>
  </head>
  <body>
    <div class="container" style = "position:fixed; left:10px; top: 550px;">
      <div class="box-1">
        <h1>Visualizing Fourier Coefficients</h1> <!-- This is the actual 'Title' of the page for the website -->
        <p>In the pulsefunction textbox enter a pulsefunction defined by any number of +/- scalar values seperated by a space. In the number of terms textbox enter a number of terms for the fourier series expansion.
        You MUST enter a range defined by floating point xmin and xmax values for multiples of pi. In the Fourier Series color, width and square color and width boxes 
        enter an integer for the width and a color hex value using the following format : #XXXXXX where X is a hex value from 0-F. Alternatively,
          check out this website on <a href="https://en.wikipedia.org/wiki/Web_colors" style="color:green"> Web Colors </a>. When ready press the submit button on the far left. In order for the +/- 5 terms
        buttons to work properly you must first press the subtract button once.</p>
        <input type="text" placeholder="Enter pulsefunction here" id="pulse">
        <input type="text" placeholder="Enter a number of terms here" id="n">
        <input type="text" placeholder="xMin" id="xMin">
        <input type="text" placeholder="xMax" id="xMax">
        <input type="text" placeholder="Fourier Series line width" id="FourierWidth">
        <input type="text" placeholder="Fourier Series color" id="FourierColor">
        <input type="text" placeholder="Square Wave line width" id="SquareWidth">
        <input type="text" placeholder="Square Wave color" id="SquareColor">
        <button type="button" onclick="getInputValue();">Submit</button>
        <button type="button" onclick="addOneTerms();">Add 1 Term</button>
        <button type="button" onclick="subOneTerms();">Sub 1 Term</button>
      </div>
    </div>
  </body>
</html>
