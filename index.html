<!DOCTYPE html>
<html>
  <head>
    <title>Visualizing Fourier Coefficients</title> <!-- Title of our website in browser -->
    <link rel="stylesheet" type="text/css" href="style.css">
    <canvas id="back" width="1420" height="500" style="border:1px solid #000000"></canvas>
    <canvas id="myCanvas" width="1420" height="500" style="border:1px solid #000000"></canvas>
    <script> <!-- type="text/javascript" src="script.js" -->
      
      
      <!-- Beginning of graph construction -->
      
      <!-- Develop textboxes for user input -->
      
      var c = document.getElementById("myCanvas");
      var ctx = c.getContext("2d");
      var n;
      var pulsefunction;
      
      function drawGraph(pulsefunction,c,ctx,n){//We need to know what attributes need to be passed to this function
        <!-- Place everything in here? -->
        
        //Take input as an array of values split on single space
        
        var i = 0;
        var pulsearray = pulsefunction.split(" ");
      
        //In a for loop find the maximum/minimum value, use the absolute value so you'll only be using positive numbers as reference
        
        var max = -Infinity;
        
        for(i = 0; i < pulsearray.length; i++){
          if(Math.abs(parseInt(pulsearray[i])) > max){
            max = Math.abs(parseInt(pulsearray[i]));
          }
        }
        
        //By this point we should know our y scale. Whatever our max value is we should have that be our max positive/negative range. 
        //This might not work as I am expecting it to work, however thats alright we'll do it now, then change it later if so.
        
      
        <!-- End of input reading -->
        
        c = document.getElementById("myCanvas");
        ctx = c.getContext("2d");
        
        ctx.clearRect(0,0,1420,500);
        ctx.beginPath(); //Apparently we need this line???
        
        //We should probably draw the y and x axis here, so that we can properly scale the graph first...
        // I'd love to do this, but javascript wont let me...
        
        <!-- This is the start of the square wave -->
        <!-- Any state transitions will require 3 lines, not 2. -->
        <!-- pi/2 and 2pi/2 are tied to 5pi/2 and 6pi/2, and 9pi/2 and 10pi/2 -->
        
        <!-- Y-axis modular variables -->
        
        var ycenter = 250;
        var ytop = 50;
        var yend = 450;
        
        <!-- Y-axis modular variables end -->
        
        <!-- X-axis modular variables -->
        
        var xstart = 100;
        var xend = 1400;
        
        <!-- X-axis modular variables end -->
        
        <!-- Modular Square Wave for 3 periods! -->
        
        //Style
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        
        <!-- So this means that each interval is in 450 pixels, so the text will look like pi/2 , 2pi/2, 3pi/2, ... until 12pi/2 -->

        ctx.font = "15px Courier New";

        <!-- From 0 to 2pi -->

        //This is no longer modular! We would ideally want to see the x-axis only show the intervals for the number of terms entered by the user.
        var twopi = 450;
        var counter = 1;//The mathematical escape character for pi should be : \u03C0
        var p = 0;
        for(p=0; p < 3; p++){//Loop for each period
          for(i=0; i < 2; i++){//Loop for each pulse value (i < pulsearray.length)
            //ctx.fillText( 2*counter+"\u03C0/"+pulsearray.length,75+(twopi/pulsearray.length)*((i+1)+(pulsearray.length*p)),ycenter + 30);//Should display proper x-axis for all three periods
            ctx.fillText( counter+"\u03C0",xstart+(twopi/2)*(counter),ycenter + 30); //Should label every pi only
            counter++;//Increment 2pi for x-axis
          }
        }
        <!-- Y-axis scale -->
        //Here is where we will add the gridlines for the y-axis
        var yScalePos = 0;
        ctx.fillText("0", xstart - 10, ycenter);
        for(i = 0; i < pulsearray.length; i++){
          yScalePos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * parseInt(pulsearray[i]) ) + ycenter;
          ctx.fillText(pulsearray[i], xstart - 10, yScalePos);
          ctx.moveTo(xstart,yScalePos);
          ctx.lineTo(xend,yScalePos);
          ctx.stroke();
        }
        ctx.fillText("f(t)",xstart - 50,ycenter - 20);

        <!-- Add the y-axis gridlines here -->
        //Every 2pi is 450 pixels from x-start. So In a loop we will add gridlines from period 1 to period 3
        counter = 1;
        for(p=0;p<3;p++){
          for(i=0; i<2; i++){
            if(counter%2 == 0){
              ctx.beginPath();
              ctx.lineWidth = 8; //For 2 pi make the gridline thickness larger
            }
            if(counter%2 != 0){
              ctx.lineWidth = 1; //Make pi line width equal to 1.
            }
            ctx.moveTo(xstart+(450/2)*counter , ytop);
            ctx.lineTo(xstart+(450/2)*counter , yend);
            counter++;
            ctx.stroke();
          }
        }
        ctx.lineWidth = 1;
        <!-- End of Y-axis creation -->
        
        <!-- Draw new axis for both graphs -->
        
        <!-- New x-axis -->
        
        ctx.moveTo(xstart-50,ycenter);
        ctx.lineTo(xend,ycenter); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        ctx.stroke();
        
        <!-- End new x-axis -->
      
        ctx.moveTo(xstart,ytop);
        ctx.lineTo(xstart,yend); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        ctx.stroke();
        ctx.fillText("t",(xstart + xend)/2,yend + 30);
        
        <!-- End of X-axis creation -->
        
        <!-- Start of Square Wave creation -->
        ctx.beginPath();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#00FF00';
        ctx.globalAlpha = 0.5;
        /*
        var x_shift = xstart;
        var y_shift = ycenter;
        
        var pc = 0;
        i = 0;
        for(pc = 0; pc < 3; pc++){
          for(i = 0; i < pulsearray.length; i++){
            ctx.moveTo(x_shift,y_shift);
            y_shift = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * (pulsearray[i]) ) + ycenter;
            ctx.lineTo(x_shift,y_shift);
            ctx.moveTo(x_shift,y_shift);
            x_shift += 450/(pulsearray.length);
            ctx.lineTo(x_shift,y_shift);
          }
        }
        
        ctx.stroke();
        */
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        ctx.globalAlpha = 1.0;
        <!-- End of Square Wave drawing -->
        
        
        <!-- This is where the points must be drawn!!!  -->
        <!-- This section of the program will plot the points for the Fourier Series! -->
        <!-- For sake of simplicity I'm going to hold off on the "0000" and "1111" waves -->

        
        //We need a robust way to calculate the integrals for the fourier coefficients
        
        //General Form for a_0 START ************************************
        //Average of the pulses
        
        var a0 = 0;
        var m = 0;
        for(m=0; m<pulsearray.length; m++){
           a0 += parseInt(pulsearray[m]); //a_0 portion
        }
        
        a0 = a0/(pulsearray.length); //division by 4 was not modular
        
        //General Form for a_0  END ************************************
        
        //General Form for a_n  START ************************************
        
        //No matter what the scenario, the integral always comes out the same. I will provide my handcalculations if necessary.
        function a_n(upper,lower,s,n){
          return ( ( Math.sin(upper*n) - Math.sin(lower*n) ) * parseInt(s) )/(Math.PI*n);
        }
        
        var aN = 0;
        
        //General Form for a_n  END ************************************
        
        //General Form for b_n  START ************************************
        
        function b_n(upper,lower,s,n){//Same as a_n but now its cos instead of sin from handcalculations
          return ( ( Math.cos(upper*n) - Math.cos(lower*n) ) * parseInt(s) )/(-1*Math.PI*n);
        }
        
        var bN = 0;
        
        //General Form for b_n END **************************************
        
        //Overall f(t) = a_0 + a_n*cos(n*t) + b_n*sin(n*t)
        //Now we can combine all three for loops into one just below this line for simplicity:
        
        var z = 0;
        var m = 0;
        n = parseInt(n);
        var p = 0;
        var y = a0;
        var aN = 0;
        var bN = 0;
        
        var coordinates = [];
        var points = [];
        var square = [];
        
        function storePointValues(xVal,yVal,array){
          array.push({x: xVal, y: yVal});
        }
        
        //We need to make this modular. If we have 3 pulses, then we need to divide 2pi by 3, so instead of pi/2 we'll have pi/3's
        //We also do not know how many divisions we'll have, so we need to modulate it.
        //We should make the below into a function, that way it wont take so long for us to display 
        function drawFourierSeries(n){
            for(p = 0; p<1350; p++){//1350
              for(z = 0; z<n; z++){ //Include n number of terms in the fourier series expansion
                for(i = 0; i < pulsearray.length; i++){
                  aN += parseInt(pulsearray[i]) *  ( Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( (z+1) * Math.PI );
                  bN += parseInt(pulsearray[i]) *  ( Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( -1 * (z+1) * Math.PI );
                }
                y += aN*Math.cos((z+1)*(p+1)*(Math.PI/225)) + bN*Math.sin((z+1)*(p+1)*(Math.PI/225));//Increment by 1/100 th instead of 1?
                //Reset aN and bN in here?
                aN = 0;
                bN = 0;
              }
              if(p < twopi){
                storePointValues(p,y,points);//store 2pi worth of points
              }
              var y_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * y ) + ycenter;//This y scale converter should provide the proper canvas point y position for the point placement 
              storePointValues(xstart + 1*(p+1), y_pos, coordinates);
              //Determine the pulse value based on the point index. If the point index is less than 
              var squareY = 0;
              var interval = twopi/pulsearray.length;
              for(i=0; i < pulsearray.length; i++){//This should really plot the first period of the square wave...
                if(p < (i+1)*interval && p >= i*interval ){
                  squareY = pulsearray[i];
                }else{
                  squareY = 0;
                }
              }
              var square_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * squareY ) + ycenter;
              storePointValues(xstart + 1*(p+1), square_pos, square);
              y = a0;
            }
            //Fourier Series smooth line
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(coordinates[0].x, coordinates[0].y);
            for(i=1; i<coordinates.length-2; i++){
              var xc = (coordinates[i].x + coordinates[i + 1].x) / 2;
              var yc = (coordinates[i].y + coordinates[i + 1].y) / 2;
              ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,xc,yc);
            }
            ctx.strokeStyle = '#775500';
            ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,coordinates[i+1].x,coordinates[i+1].y);
            ctx.stroke();
            //Square wave smooth line
            ctx.beginPath();
            ctx.lineWidth = 4;
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(square[0].x, square[0].y);
            for(i=1; i<square.length-2; i++){
              var xc = (square[i].x + square[i + 1].x) / 2;
              var yc = (square[i].y + square[i + 1].y) / 2;
              ctx.quadraticCurveTo(square[i].x,square[i].y,xc,yc);
            }
            ctx.strokeStyle = '#FFF000';//Different color for square wave
            ctx.quadraticCurveTo(square[i].x,square[i].y,square[i+1].x,square[i+1].y);
            ctx.stroke();
        }
        //I need to save the image of the canvas before we draw the Fourier Series
        ctx.stroke();
        drawFourierSeries(n);
        //To develop the y scale converter we need to know the position of the Max/Min element (This should be at the very top and/or very bottom of the y axis)
        //Max y coordinate: 20  Min y coordinate: 480, so we should have 3 points really, Max, Min, center
        //Center y coordinate: 250
        
        // (max,480) , (0,250)
        //We can make a line like last time with 2 points the y intercept and the max for simplicity:
        //y = mx + b
        //b = 250
        //m = (max-0)/(480-250)
        //y = ( (250-20) )/(0-max)  * y_ + 250
        <!-- Calculate the average error per period -->
        var error = 0;
        for(p = 0; p < twopi; p++){//We need to figure out which points belong to which pulse value
          for(i = 0; i < pulsearray.length; i++){
            if(p < (twopi/pulsearray.length) * (i+1) && p > (twopi/pulsearray.length) * i){//If the point lies inside pulse value index i:
              error += Math.abs(points[p].y - pulsearray[i]); //Absolute value of the difference between the approximation and actual point value.
            }
          }
        }
        //Now to get the average we need to take the error and divide it by 450 because there are 450 points per period.
        error = error / 450;
        ctx.fillText("Average error per period: " + error,10,10);//Place average error on the top left hand corner of canvas
        
      }
      
      function getInputValue(){
        
        pulsefunction = document.getElementById("pulse").value;
        n = document.getElementById("n").value;
        
        this.drawGraph(pulsefunction,c,ctx,n);//This function should draw the graphs input by the user to the canvas
        
      }
      
      function addFiveTerms(){
        n = n+5;
        this.drawGraph(pulsefunction,c,ctx,n);//This function should draw the graphs input by the user to the canvas
      }
      function subFiveTerms(){
        n = n-5;
        this.drawGraph(pulsefunction,c,ctx,n);//This function should draw the graphs input by the user to the canvas
      }
      
    </script>
  </head>
  <body>
    <div class="container" style = "position:fixed; left:500px; top: 500px;">
      <div class="box-1">
        <h1>Visualizing Fourier Coefficients</h1> <!-- This is the actual 'Title' of the page for the website -->
        <p>In the bottom left textbox enter a pulsefunction defined by any number of +/- scalar values seperated by a space. In the box next to it enter a number of terms for the fourier series expansion.
        When ready press the submit button on the far left.</p>
        <input type="text" placeholder="Enter pulsefunction here" id="pulse">
        <input type="text" placeholder="Enter a number of terms here" id="n">
        <button type="button" onclick="getInputValue();">Submit</button>
        <button type="button" onclick="addFiveTerms();">Add 5 Terms</button>
        <button type="button" onclick="subFiveTerms();">Sub 5 Terms</button>
      </div>
    </div>
  </body>
</html>

