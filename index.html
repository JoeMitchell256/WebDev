<!DOCTYPE html>
<html>
  <head>
    <title>Visualizing Fourier Coefficients</title> <!-- Title of our website in browser -->
    <link rel="stylesheet" type="text/css" href="style.css">
    <canvas id="back" width="1420" height="550" style="border:1px solid #000000"></canvas>
    <canvas id="myCanvas" width="1420" height="550" style="border:1px solid #000000"></canvas>
    <script> 
      
      var c = document.getElementById("myCanvas");
      var ctx = c.getContext("2d");
      var n, pulsefunction, xMin, xMax, FourierWidth, FourierColor, SquareWidth, SquareColor;
      
      function drawGraph(pulsefunction,c,ctx,n,xmin,xmax,fw,fc,sw,sc){//We need to know what attributes need to be passed to this function
        //Calculate the point value for the xmin and xmax inputs
        var twopi = 450;
        xmin = parseFloat(xmin);
        xmax = parseFloat(xmax);
        var xMinPval = Math.ceil(twopi/2 * parseFloat(xmin));
        var xMaxPval = Math.ceil(twopi/2 * parseFloat(xmax));
        var i = 0;
        var pulsearray = pulsefunction.split(" ");//Take input as an array of values split on single space
      
        //In a for loop find the maximum/minimum value, use the absolute value so you'll only be using positive numbers as reference
        
        var max = -Infinity;
        
        for(i = 0; i < pulsearray.length; i++){
          if(Math.abs(parseInt(pulsearray[i])) > max){
            max = Math.abs(parseInt(pulsearray[i]));
          }
        }
        
        //By this point we should know our y scale. Whatever our max value is we should have that be our max positive/negative range. 
        //This might not work as I am expecting it to work, however thats alright we'll do it now, then change it later if so.
        
      
        <!-- End of input reading -->
        
        c = document.getElementById("myCanvas");
        ctx = c.getContext("2d");
        
        ctx.clearRect(0,0,1420,500);
        ctx.beginPath(); //Apparently we need this line???
        
        //We should probably draw the y and x axis here, so that we can properly scale the graph first...
        // I'd love to do this, but javascript wont let me...
        
        <!-- This is the start of the square wave -->
        <!-- Any state transitions will require 3 lines, not 2. -->
        <!-- pi/2 and 2pi/2 are tied to 5pi/2 and 6pi/2, and 9pi/2 and 10pi/2 -->
        
        <!-- Y-axis modular variables -->
        
        var ycenter = 250;
        var ytop = 50;
        var yend = 450;
        
        <!-- Y-axis modular variables end -->
        
        <!-- X-axis modular variables -->
        
        var xstart = 100;
        var xend = 1400;
        
        <!-- X-axis modular variables end -->
        
        <!-- Modular Square Wave for 3 periods! -->
        
        //Style
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        
        <!-- So this means that each interval is in 450 pixels, so the text will look like pi/2 , 2pi/2, 3pi/2, ... until 12pi/2 -->

        ctx.font = "30px Courier New";

        <!-- From 0 to 2pi -->

        //This is no longer modular! We would ideally want to see the x-axis only show the intervals for the number of terms entered by the user.
        
        var counter = 1;//The mathematical escape character for pi should be : \u03C0
        var p = 0;
        for(p=0; p < 3; p++){//Loop for each period
          for(i=0; i < 2; i++){//Loop for each pulse value (i < pulsearray.length)
            if(counter == 1){
              ctx.fillText( "\u03C0",xstart+(twopi/2)*(counter),yend + 60); //Should label every pi only
            }else{
              ctx.fillText( counter+"\u03C0",xstart+(twopi/2)*(counter),yend + 60); //Should label every pi only
            }
            counter++;//Increment 2pi for x-axis
          }
        }
        
        <!-- Y-axis scale -->
        //Here is where we will add the gridlines for the y-axis
        //Instead of this, we want to take the max value and add gridlines from that integer value all the way to the absolute value of that integer.
        var yScalePos = 0;
        for(i = -max; i < max+1; i++){
          yScalePos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * i ) + ycenter;
          ctx.fillText(i, xstart - 10, yScalePos);
          ctx.moveTo(xstart,yScalePos);
          ctx.lineTo(xend,yScalePos);
          ctx.stroke();
        }
        ctx.fillText("f(t)",xstart - 50,ycenter - 20);
        ctx.stroke();
        
        ctx.font = "30px Courier New";
        
        <!-- Add the y-axis gridlines here -->
        //Every 2pi is 450 pixels from x-start. So In a loop we will add gridlines from period 1 to period 3
        counter = 1;
        for(p=0;p<3;p++){
          for(i=0; i<2; i++){
            if(counter%2 == 0){
              ctx.beginPath();
              ctx.lineWidth = 8; //For 2 pi make the gridline thickness larger
            }
            if(counter%2 != 0){
              ctx.lineWidth = 1; //Make pi line width equal to 1.
            }
            ctx.moveTo(xstart+(450/2)*counter , ytop);
            ctx.lineTo(xstart+(450/2)*counter , yend);
            counter++;
            ctx.stroke();
          }
        }
        ctx.lineWidth = 1;
        <!-- End of Y-axis creation -->
        
        <!-- Draw new axis for both graphs -->
        
        <!-- New x-axis -->
        
        ctx.moveTo(xstart-50,ycenter);
        ctx.lineTo(xend,ycenter); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        ctx.stroke();
        
        <!-- End new x-axis -->
      
        ctx.moveTo(xstart,ytop);
        ctx.lineTo(xstart,yend); <!-- The total x-axis distance is from 1400-50 = 1350. If we want 3 periods we want to to take intervals of 1350/3 = 450 -->
        ctx.stroke();
        ctx.fillText("t/T",(xstart + xend)/2,yend + 100);
        
        <!-- End of X-axis creation -->
        
        <!-- Start of Square Wave creation -->
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#000000';
        ctx.globalAlpha = 1.0;
        <!-- End of Square Wave drawing -->
        
        
        <!-- This is where the points must be drawn!!!  -->
        <!-- This section of the program will plot the points for the Fourier Series! -->
        <!-- For sake of simplicity I'm going to hold off on the "0000" and "1111" waves -->

        
        //We need a robust way to calculate the integrals for the fourier coefficients
        
        //General Form for a_0 START ************************************
        //Average of the pulses
        
        var a0 = 0;
        var m = 0;
        for(m=0; m<pulsearray.length; m++){
           a0 += parseInt(pulsearray[m]); //a_0 portion
        }
        
        a0 = a0/(pulsearray.length); //division by 4 was not modular
        
        //General Form for a_0  END ************************************
        
        //General Form for a_n  START ************************************
        
        //No matter what the scenario, the integral always comes out the same. I will provide my handcalculations if necessary.
        function a_n(upper,lower,s,n){
          return ( ( Math.sin(upper*n) - Math.sin(lower*n) ) * parseInt(s) )/(Math.PI*n);
        }
        
        var aN = 0;
        
        //General Form for a_n  END ************************************
        
        //General Form for b_n  START ************************************
        
        function b_n(upper,lower,s,n){//Same as a_n but now its cos instead of sin from handcalculations
          return ( ( Math.cos(upper*n) - Math.cos(lower*n) ) * parseInt(s) )/(-1*Math.PI*n);
        }
        
        var bN = 0;
        
        //General Form for b_n END **************************************
        
        //Overall f(t) = a_0 + a_n*cos(n*t) + b_n*sin(n*t)
        //Now we can combine all three for loops into one just below this line for simplicity:
        
        var z = 0;
        var m = 0;
        n = parseInt(n);
        var p = 0;
        var y = a0;
        var aN = 0;
        var bN = 0;
        
        var coordinates = [];
        var points = [];
        var square = [];
        
        function storePointValues(xVal,yVal,array){
          array.push({x: xVal, y: yVal});
        }
        
        function squareYpos(p,twopi){//Based on the point value this function will return the y pulse value
          //Take the point value and place the value in the range from 0 to twopi (450)
          //Then determine if the point belongs to the particular pulsevalue
          var pulse = p;
          while(pulse > twopi){
            pulse = pulse - twopi;
          }
          var squareY = 0;
          for(i = 0; i < pulsearray.length; i++){
            if(pulse < (i + 1) * twopi/pulsearray.length && pulse >= i * twopi/pulsearray.length){
              squareY = pulsearray[i]; //Assign the proper pulse value based on the point index
            }
          }
          return squareY; //Return the proper pulse value based on the point index
        }
        
        //We need to make this modular. If we have 3 pulses, then we need to divide 2pi by 3, so instead of pi/2 we'll have pi/3's
        //We also do not know how many divisions we'll have, so we need to modulate it.
        //We should make the below into a function, that way it wont take so long for us to display 
        function drawFourierSeries(n){
            for(p = 0; p<1350; p++){//1350
              for(z = 0; z<n; z++){ //Include n number of terms in the fourier series expansion
                for(i = 0; i < pulsearray.length; i++){
                  aN += parseInt(pulsearray[i]) *  ( Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.sin( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( (z+1) * Math.PI );
                  bN += parseInt(pulsearray[i]) *  ( Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * (i+1) ) - Math.cos( ( (z+1) * 2 * Math.PI/(pulsearray.length) ) * i ) ) / ( -1 * (z+1) * Math.PI );
                }
                y += aN*Math.cos((z+1)*(p+1)*(Math.PI/225)) + bN*Math.sin((z+1)*(p+1)*(Math.PI/225));//Increment by 1/100 th instead of 1?
                //Reset aN and bN in here?
                aN = 0;
                bN = 0;
              }
              if(p < twopi){
                storePointValues(p,y,points);//store 2pi worth of points
              }
              var y_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * y ) + ycenter;//This y scale converter should provide the proper canvas point y position for the point placement 
              storePointValues(xstart + 1*(p+1), y_pos, coordinates);
              //Determine the pulse value based on the point index using the squareYpos function defined above
              var square_pos = ( ( (ycenter-ytop)/(0-parseInt(max)) ) * squareYpos(p,twopi) ) + ycenter;
              storePointValues(xstart + 1*(p+1), square_pos, square);
              y = a0;
            }
            //Fourier Series smooth line
            ctx.beginPath();
            ctx.lineWidth = parseInt(fw);//Line thickness of the Fourier Series
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(coordinates[xMinPval].x, coordinates[xMinPval].y);//This moveTo is now robust
            for(i=1; i<coordinates.length-2; i++){
              if(i >= xMinPval && i < xMaxPval){
                var xc = (coordinates[i].x + coordinates[i + 1].x) / 2;
                var yc = (coordinates[i].y + coordinates[i + 1].y) / 2;
                ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,xc,yc);
              }
            }
            ctx.strokeStyle = fc;//Color of the Fourier Series line '#775500'
            if(i >= xMinPval && i < xMaxPval){
              ctx.quadraticCurveTo(coordinates[i].x,coordinates[i].y,coordinates[i+1].x,coordinates[i+1].y);
            }
            ctx.stroke();
            //Square wave smooth line
            ctx.beginPath();
            ctx.lineWidth = parseInt(sw);//Line thickness of the square wave
            ctx.globalAlpha = 0.5; //Should make the fourier series transparent
            ctx.moveTo(square[xMinPval].x, square[xMinPval].y);
            for(i=1; i<square.length-2; i++){
              if(i >= xMinPval && i < xMaxPval){
                var xc = (square[i].x + square[i + 1].x) / 2;
                var yc = (square[i].y + square[i + 1].y) / 2;
                ctx.quadraticCurveTo(square[i].x,square[i].y,xc,yc);
              }
            }
            ctx.strokeStyle = sc;//Different color for square wave '#00FF00'
            if(i >= xMinPval && i < xMaxPval){
              ctx.quadraticCurveTo(square[i].x,square[i].y,square[i+1].x,square[i+1].y);
            }
            ctx.stroke();
        }
        //I need to save the image of the canvas before we draw the Fourier Series
        ctx.stroke();
        drawFourierSeries(n);
        //To develop the y scale converter we need to know the position of the Max/Min element (This should be at the very top and/or very bottom of the y axis)
        //Max y coordinate: 20  Min y coordinate: 480, so we should have 3 points really, Max, Min, center
        //Center y coordinate: 250
        
        // (max,480) , (0,250)
        //We can make a line like last time with 2 points the y intercept and the max for simplicity:
        //y = mx + b
        //b = 250
        //m = (max-0)/(480-250)
        //y = ( (250-20) )/(0-max)  * y_ + 250
        <!-- Calculate the average error per period -->
        var error = 0;
        for(p = 0; p < twopi; p++){//We need to figure out which points belong to which pulse value
          for(i = 0; i < pulsearray.length; i++){
            if(p < (twopi/pulsearray.length) * (i+1) && p > (twopi/pulsearray.length) * i){//If the point lies inside pulse value index i:
              error += Math.abs(points[p].y - pulsearray[i]); //Absolute value of the difference between the approximation and actual point value.
            }
          }
        }
        //Now to get the average we need to take the error and divide it by 450 because there are 450 points per period.
        error = error / 450;
        ctx.fillText("Average error: " + error,10,yend+30);//Place average error on the top left hand corner of canvas
        
      }
      
      function getInputValue(){
        
        pulsefunction = document.getElementById("pulse").value;
        n = document.getElementById("n").value;
        xMin = document.getElementById("xMin").value;
        xMax = document.getElementById("xMax").value;
        FourierWidth = document.getElementById("FourierWidth").value;
        FourierColor = document.getElementById("FourierColor").value;
        SquareWidth = document.getElementById("SquareWidth").value;
        SquareColor = document.getElementById("SquareColor").value;
        
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
        
      }
      
      function addFiveTerms(){
        n = n+5;
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
      }
      function subFiveTerms(){
        n = n-5;
        this.drawGraph(pulsefunction,c,ctx,n,xMin,xMax,FourierWidth,FourierColor,SquareWidth,SquareColor);//This function should draw the graphs input by the user to the canvas
      }
      
    </script>
  </head>
  <body>
    <div class="container" style = "position:fixed; left:10px; top: 550px;">
      <div class="box-1">
        <h1>Visualizing Fourier Coefficients</h1> <!-- This is the actual 'Title' of the page for the website -->
        <p>In the pulsefunction textbox enter a pulsefunction defined by any number of +/- scalar values seperated by a space. In the number of terms textbox enter a number of terms for the fourier series expansion.
        You MUST enter a range defined by floating point xmin and xmax values for multiples of pi. In the Fourier Series color, width and square color and width boxes 
        enter an integer for the width and a color hex value using the following format : #XXXXXX where X is a hex value from 0-F. When ready press the submit button on the far left. In order for the +/- 5 terms
        buttons to work properly you must first press the subtract button once.</p>
        <input type="text" placeholder="Enter pulsefunction here" id="pulse">
        <input type="text" placeholder="Enter a number of terms here" id="n">
        <input type="text" placeholder="xMin" id="xMin">
        <input type="text" placeholder="xMax" id="xMax">
        <input type="text" placeholder="Fourier Series line width" id="FourierWidth">
        <input type="text" placeholder="Fourier Series color" id="FourierColor">
        <input type="text" placeholder="Square Wave line width" id="SquareWidth">
        <input type="text" placeholder="Square Wave color" id="SquareColor">
        <button type="button" onclick="getInputValue();">Submit</button>
        <button type="button" onclick="addFiveTerms();">Add 5 Terms</button>
        <button type="button" onclick="subFiveTerms();">Sub 5 Terms</button>
      </div>
    </div>
  </body>
</html>
